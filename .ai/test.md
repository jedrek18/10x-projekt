1. Encje bazowe: users (profiles, FK → auth.users), flashcards, srs_state (jeśli nie w flashcards), reviews (historia ocen), generation_events, save_batches, save_items (łącznik batch→karta), kpi_event_log (opcjonalnie), user_settings (np. time_zone, daily_goal).
2. Ograniczenia: flashcards.front TEXT CHECK (char_length(front) ≤ 200), flashcards.back TEXT CHECK (char_length(back) ≤ 500), flashcards.source CHECK (source IN ('ai','ai_edited','manual')); wszystkie timestamptz.
3. Indeksy: (user_id, created_at DESC) dla „Moje fiszki”; (user_id, due_at) dla kolejek SRS; (user_id, state, due_at) partial na state IN ('review','learning'); unikalny (user_id, client_item_id) jeżeli stosujemy idempotencję per karta.
4. Idempotencja zapisu: tabela save_batches(user_id, client_batch_id UNIQUE, requested_count, created_at) + save_items(batch_id, client_item_id UNIQUE NULLABLE, payload_hash). Wstawianie kart robi UPSERT po (user_id, client_item_id) lub (user_id, payload_hash) z no-op przy duplikacie.
5. SRS: przechowuj w flashcards kolumny due_at timestamptz, interval_days INT, ease_factor NUMERIC(5,2), reps INT, lapses INT, state TEXT CHECK (...). Zmiany stanu wyłącznie przez funkcję RPC review_flashcard(user_id, card_id, rating) (SECURITY DEFINER), a RLS UPDATE na tych kolumnach zablokować.
6. Telemetria: generation_events(id UUID, user_id, model_id, slider_target, generated_count, char_count, request_id UNIQUE, created_at); zapis kart od AI referencjonuje optional generation_event_id w save_batches do KPI. Logi zapisu: kpi_event_log(event_type, user_id, counts_by_label JSONB, created_at).
7. RLS: polityki per tabela: użytkownik może SELECT/INSERT/UPDATE/DELETE tylko w wierszach z user_id = auth.uid(); na telemetrii – INSERT do generation_events/kpi_event_log dozwolony użytkownikowi (bez SELECT) lub wyłącznie przez RPC; agregacje dostępne tylko przez widoki MATERIALIZED + dostęp service role.
8. Usuwanie: ON DELETE CASCADE od profiles(user_id) → flashcards/reviews/save_*; rozważ funkcję delete_account(user_id) (SECURITY DEFINER) wykonującą kaskadę i ewentualną anonimizację telemetrii.
9. Spójność/konkurencja: dodaj updated_at timestamptz + version INT dla flashcards; wymuś „optimistic locking” (WHERE id=? AND version=?), aby rozwiązać konflikty edycji (FR-020).
10. Skalowanie: brak partycjonowania w MVP; przygotuj się na przyszłe RANGE partitioning po due_at lub HASH po user_id dla reviews, jeśli wolumen >10M; już teraz używaj ON COMMIT NOTHING, autovacuum tuned i krótkich indeksów (avoid text indexes w MVP). 